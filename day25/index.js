const { readFileSync } = require('fs');
const { EOL } = require('os');

// generalized recursion helper
function until(seed, step, predicate) {
    while(!predicate(seed)) {
        seed = step(seed);
    }
    return seed;
}

const lines = readFileSync('./input.txt').toString().trim().split(EOL);

const part1 = [until([['', Infinity], lines.map(line => line.split(': ')).reduce((weights, [from, rest]) => rest.split(' ').reduce((weights, to) => Object.assign(weights, {[from]: Object.assign(weights[from] || {}, {[to]: 1}),  [to]: Object.assign(weights[to] || {}, {[from]: 1})}), weights), {})], ([[minCut, minCutWeight], weights]) => [[until([new Set([Object.keys(weights)[0]])].flatMap(A => [A, Object.keys(weights).slice(1).reduce((V, k) => until([[V].flatMap(V => [V, V.push(k)])[0], V.length - 1], ([V, idx]) => [Object.assign(V, {[idx]: V[Math.floor(idx / 2)], [Math.floor(idx / 2)]: V[idx]}), Math.floor(idx / 2)], ([V, idx]) => idx <= 1 || [idx, Math.floor(idx / 2)].map(i => [i, Object.entries(weights[V[i]] || []).reduce((total, [k, v]) => total + (A.has(k) ? v : 0), 0)]).sort(({1: a}, {1: b}) => a - b)[0][0] === idx)[0], [null])]), ([A, V]) => [Object.assign(V, {[1]: V[V.length - 1], [V.length - 1]: V[1]})].map(V => [V.pop(), until([V, 1], ([V, idx]) => [[idx * 2, idx * 2 + 1].map(i => [i, Object.entries(weights[V[i]] || []).reduce((total, [k, v]) => total + (A.has(k) ? v : 0), 0)]).sort(({1: a}, {1: b}) => a - b)[1][0]].reduce(([V], cidx) => [Object.assign(V, {[idx]: V[cidx], [cidx]: V[idx]}), cidx], [V]), ([V, idx]) => idx >= V.length || [idx * 2, idx * 2 + 1, idx].map(i => [i, Object.entries(weights[V[i]] || []).reduce((total, [k, v]) => total + (A.has(k) ? v : 0), 0)]).sort(({1: a}, {1: b}) => a - b)[2][0] === idx)[0]]).flatMap(([z, V]) => [A.add(z), Object.keys(weights[z]).filter(k => V.includes(k)).reduce((V, w) => until([V, V.indexOf(w)], ([V, idx]) => [Object.assign(V, {[idx]: V[Math.floor(idx / 2)], [Math.floor(idx / 2)]: V[idx]}), Math.floor(idx / 2)], ([V, idx]) => idx <= 1 || [idx, Math.floor(idx / 2)].map(i => [i, Object.entries(weights[V[i]] || []).reduce((total, [k, v]) => total + (A.has(k) ? v : 0), 0)]).sort(({1: a}, {1: b}) => a - b)[0][0] === idx)[0], V)]), ([_, V]) => V.length - 1 <= 2)].flatMap(([A, V]) => (V.length - 1 === 1) ? [[...A][0], V[1]] : [V[1], V[2]])].flatMap(([s, t]) => [Object.values(weights[t]).reduce((a, b) => a + b) < minCutWeight ? [t, Object.values(weights[t]).reduce((a, b) => a + b)] : [minCut, minCutWeight], Object.fromEntries(Object.entries([s, t].reduce((weights, x) => Object.entries(weights[x]).filter(([k]) => k !== `${s}.${t}`).reduce((weights, [k, w]) => Object.assign(weights, {[k]: Object.fromEntries([...Object.entries(weights[k]).filter(([e]) => e !== x), [`${s}.${t}`, (weights[`${s}.${t}`][k] || 0) + w]])}), weights), Object.assign(weights, {[`${s}.${t}`]: Object.fromEntries([...Object.keys(weights[s]), ...Object.keys(weights[t])].map(k => [k, (weights[s][k] || 0) + (weights[t][k] || 0)]).filter(([k]) => k !== s && k !== t && k !== `${s}.${t}`))}))).filter(([k]) => k !== s && k !== t))]), ([_, weights]) => Object.keys(weights).length === 1)].map(([currentMinimumCut, weights]) => currentMinimumCut[0].split('.').length * (Object.keys(weights)[0].split('.').length -  currentMinimumCut[0].split('.').length))[0]

console.log(part1);
